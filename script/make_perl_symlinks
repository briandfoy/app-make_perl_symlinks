#!/Users/brian/bin/perl
use 5.034;
use utf8;
use open qw(:std :utf8);
use warnings;
use experimental qw(signatures);

use Antsy                 qw(:all);
use File::Basename;
use File::Spec::Functions qw(rel2abs catfile);
use File::Path            qw(make_path);
use List::Util            qw(max);
use Perl::Version;
use Term::ReadKey         qw(GetTerminalSize);

use constant CHECKMARK => bold . text_green . "\x{2705}" . reset;
use constant CROSS     => bold . text_red   . "\x{274C}" . reset;
use constant COLUMNS   => (GetTerminalSize)[0];
use constant ROWS      => (GetTerminalSize)[1];

sub am_debugging () { !! $ENV{'DEBUG'} }
sub debug    ($message) { _message( "[debug] $message" ) }
unless( am_debugging ) { no warnings qw(redefine); *debug = sub { 1 } }

my $links_directory = $ARGV[1] // catfile( $ENV{HOME}, 'bin', 'perls' );
make_path $links_directory;
die bold . text_red . "$links_directory does not exist!" . reset . "\n"
	unless -d $links_directory;

cleanup_dead_symlinks( $links_directory );
my @perls_directories = get_perl_directories();

# say dumper(\@perls_directories);

my $count = 0;
DIRECTORY: foreach my $tuple ( @perls_directories ) {
	clear();
	next unless -e $tuple->[0];
	$count += make_links( $tuple->[0], join('.', $tuple->[1]->@*) );
	done( dirname dirname $tuple->[0] );
	}
done( "Made $count symlinks in $links_directory" );

sub cleanup_dead_symlinks ( $dir ) {
	progress_overwrite("Cleaning up dead links");
	my @problem_links =
		map {
			say "Unlinking dead link <$_>";
			unlink ? () : do {
				warn "Could not remove <$_>: $!\n";
				$_;
				};
			}
		grep { ! -e readlink }
		grep { -l }
		map { rel2abs( $_, $dir ) }
		glob( catfile $dir, '*' );

	@problem_links == 0
		?
	done("Cleaned up dead links")
		:
	problem("There were leftover dead links")
	;

	}

sub dumper { state $rc = require Data::Dumper; Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump }

sub get_perl_directories ( $base = '/usr/local/perls' ) {
	my @perls_directories =
		sort {
			$a->[1][1] <=> $b->[1][1]
				or
			$a->[1][2] <=> $b->[1][2]
			}
		map {
			[ $_, get_perl_version($_)]
			}
		grep { -e }
		map {
			catfile $_, qw(bin perl)
			}
		glob( catfile $base, '*' );
	}

sub get_perl_version ($path) {
	my $output = `$path -v`;
	return do {
		if( $output =~ /v (5) \. (\d+) \. (\d+) /xa ) {
			[ @{^CAPTURE} ];
			}
		else {
			[];
			}
		};
	}

sub cleanup_source_dir ( $dir ) {
	my( $version ) = $dir =~ m{/perl-(.+?)(?:/|$)};
	my $perl  = catfile( $dir, 'bin', 'perl' );
	my $vperl = $perl . $version;

	my @tuples = [ $perl, $vperl ];
	push @tuples, [ reverse $tuples[0]->@* ];

	foreach my $t ( @tuples ) {
		next unless( -e $t->[0] and !(-e $t->[1]) );
		debug( "Symlinking <$t->[0]> to <$t->[1]>" );
		symlink $t->[0], $t->[1];
		}

	$vperl;
	}

sub make_links ( $perl_path, $version_string, $links_dir = $links_directory ) {
	my @bins = glob( catfile( dirname($perl_path), '*' ) );

	my $count = 0;
	foreach my $bin ( @bins ) {
		debug( "\tlooking at $bin" );
		my $link_basename = do {
			my $basename = basename( $bin );
			if( $basename =~ m/5\.\d+\.\d+\z/) { $basename }
			else                               { "$basename$version_string" }
			};

		my $link = catfile( $links_directory, $link_basename );
		next if( -l $link and $bin eq readlink $link );
		$count++;
		progress_overwrite( sprintf "%s linking %s", '   ', $bin );

		unless( -e $link ) {
			symlink $bin => $link or
				problem( "  Could not create bin symlink [$!]: $bin => $link!" );
			}
		}

	return $count;
	}

sub make_latest ( $latest ) {
	my( $dir, $version ) = ( $latest->[0], "$latest->[1]" );

	foreach my $bin ( glob( catfile( $dir, 'bin', '*' ) ) ) {
		my $basename = basename( $bin );
		$basename =~ s/5\.\d+\.\d+\z//;

		my $link = catfile( $links_directory, $basename );
		progress( sprintf "%s linking %s => %s", '   ', $bin, $link );
		if( -e $link ) {
			unlink $link or problem( "Could not unlink <$link>: $!" );
			}
		symlink $bin, $link or
			problem( "Could not create latest symlink [$!]: <$bin> => <$link>!" );
		}
	}

sub clear () { print +(' ' x COLUMNS) . "\r" }

sub _message ($message, $ansi = [], $fh = \*STDOUT) {
	$message =~ s/ (?[ [\s] - [\r] ])* \z//x;
	print { $fh } $ansi->@*, $message, reset, $message =~ m/\v/ ? '' : "\n";
	}

sub done     ($message) { clear(); _message( CHECKMARK . '  ' . $message,                    ) }
sub header   ($message) { _message(                    $message, [bold, text_cyan]  ) }
sub problem  ($message) { _message( CROSS . '  ' .     $message, [bold, text_red]   ) }
sub progress ($message) { _message( '  ' .             $message, [bold, text_green] ) }

sub progress_overwrite ($message) {
	state $separator = am_debugging ? "\n" : "\r";
	_message( (' ' x ROWS) . "\r" ) unless am_debugging;
	_message( '  ' .             $message . $separator, [bold, text_green] );
	}

__END__
my $latest_name = '/Users/brian/bin/perls/perl-latest';
unlink $latest_name;
symlink $latest->[2], $latest_name or warn $!;
