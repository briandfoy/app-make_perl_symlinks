#!/Users/brian/bin/perl
use 5.034;
use utf8;
use open qw(:std :utf8);
use warnings;
use experimental qw(signatures);

use Antsy                 qw(:all);
use File::Basename;
use File::Spec::Functions qw(rel2abs catfile);
use File::Path            qw(make_path);
use List::Util            qw(max);
use Perl::Version;
use Term::ReadKey         qw(GetTerminalSize);

use constant CHECKMARK => bold . text_green . "\x{2705}" . reset;
use constant CROSS     => bold . text_red   . "\x{274C}" . reset;
use constant COLUMNS   => (GetTerminalSize)[0];
use constant ROWS      => (GetTerminalSize)[1];

=encoding utf8

=head1 NAME

make_perl_symlinks - create version-labeled symlinks to perl tools

=head1 SYNOPSIS

	% make_perl_symlinks

=head1 DESCRIPTION

I have many Perl installations, all under F</usr/local/perls>, such as F</usr/local/perls/perl-5.40.0>.
Instead of putting all of those in my C<PATH>, I make symlinks under F<$ENV{HOME}/bin/perls> so
I can use a particular version of a tool by the short name, such as F<perl5.40.3> of F<cpan5.40.3>.

	$ ls -l /Users/brian/bin/perls | grep 5.40.3
	lrwxrwxr-x@ 1 brian  staff  41 Sep  2 18:24 corelist5.40.3 -> /usr/local/perls/perl-5.40.3/bin/corelist
	lrwxrwxr-x@ 1 brian  staff  37 Sep  2 18:24 cpan5.40.3 -> /usr/local/perls/perl-5.40.3/bin/cpan
	lrwxrwxr-x@ 1 brian  staff  39 Sep  2 18:24 enc2xs5.40.3 -> /usr/local/perls/perl-5.40.3/bin/enc2xs
	...
	lrwxrwxr-x@ 1 brian  staff  37 Sep  2 18:24 perl5.40.3 -> /usr/local/perls/perl-5.40.3/bin/perl
	...

I also make links such as F<perl-latest> to point to whatever version is the
highest version I have installed:

	$ ls -l /Users/brian/bin/perls | grep latest
	lrwxrwxr-x@ 1 brian  staff  43 Sep  2 19:37 cpan-audit-latest -> /usr/local/perls/perl-5.42.0/bin/cpan-audit
	lrwxrwxr-x@ 1 brian  staff  37 Sep  2 19:37 cpan-latest -> /usr/local/perls/perl-5.42.0/bin/cpan
	lrwxrwxr-x@ 1 brian  staff  44 Sep  2 19:37 cpan-upload-latest -> /usr/local/perls/perl-5.42.0/bin/cpan-upload
	...
	lrwxrwxr-x@ 1 brian  staff  43 Sep  2 19:37 perl-latest -> /usr/local/perls/perl-5.42.0/bin/perl5.42.0
	lrwxrwxr-x@ 1 brian  staff  47 Sep  2 19:37 perl-reversion-latest -> /usr/local/perls/perl-5.42.0/bin/perl-reversion
	lrwxrwxr-x@ 1 brian  staff  40 Sep  2 19:37 perlbug-latest -> /usr/local/perls/perl-5.42.0/bin/perlbug
	lrwxrwxr-x@ 1 brian  staff  40 Sep  2 19:37 perldoc-latest -> /usr/local/perls/perl-5.42.0/bin/perldoc
	...

=head1 TO DO

=head1 SEE ALSO

=head1 SOURCE AVAILABILITY

This source is in Github:

	http://github.com/briandfoy/app-make_perl_symlinks

=head1 AUTHOR

brian d foy, C<< <briandfoy@pobox.com> >>

=head1 COPYRIGHT AND LICENSE

Copyright Â© 2025, brian d foy, All Rights Reserved.

You may redistribute this under the terms of the Artistic License 2.0.

=cut

sub am_debugging () { !! $ENV{'DEBUG'} }
sub debug    ($message) { _message( "[debug] $message" ) }
unless( am_debugging ) { no warnings qw(redefine); *debug = sub { 1 } }

my $links_directory = $ARGV[1] // catfile( $ENV{HOME}, 'bin', 'perls' );
make_path $links_directory;
die bold . text_red . "$links_directory does not exist!" . reset . "\n"
	unless -d $links_directory;

cleanup_dead_symlinks( $links_directory );
my @perls_directories = get_perl_directories();

make_latest( $perls_directories[-1][0] );
done( "Made latest symlinks for @{[ join '.', $perls_directories[-1][1]->@* ]} in $links_directory" );
# say dumper(\@perls_directories);

my $count = 0;
DIRECTORY: foreach my $tuple ( @perls_directories ) {
	clear();
	next unless -e $tuple->[0];
	$count += make_links( $tuple->[0], join('.', $tuple->[1]->@*) );
	done( "Made symlinks for " . dirname dirname $tuple->[0] );
	}
done( "Made $count symlinks in $links_directory" );

sub cleanup_dead_symlinks ( $dir ) {
	progress_overwrite("Cleaning up dead links");
	my @problem_links =
		map {
			say "Unlinking dead link <$_>";
			unlink ? () : do {
				warn "Could not remove <$_>: $!\n";
				$_;
				};
			}
		grep { ! -e readlink }
		grep { -l }
		map { rel2abs( $_, $dir ) }
		glob( catfile $dir, '*' );

	@problem_links == 0
		?
	done("Cleaned up dead links")
		:
	problem("There were leftover dead links")
	;

	}

sub dumper { state $rc = require Data::Dumper; Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump }

sub get_perl_directories ( $base = '/usr/local/perls' ) {
	my @perls_directories =
		sort {
			$a->[1][1] <=> $b->[1][1]
				or
			$a->[1][2] <=> $b->[1][2]
			}
		map {
			[ $_, get_perl_version($_)]
			}
		grep { -e }
		map {
			catfile $_, qw(bin perl)
			}
		glob( catfile $base, '*' );
	}

sub get_perl_version ($path) {
	my $output = `$path -v`;
	return do {
		if( $output =~ /v (5) \. (\d+) \. (\d+) /xa ) {
			[ @{^CAPTURE} ];
			}
		else {
			[];
			}
		};
	}

sub cleanup_source_dir ( $dir ) {
	my( $version ) = $dir =~ m{/perl-(.+?)(?:/|$)};
	my $perl  = catfile( $dir, 'bin', 'perl' );
	my $vperl = $perl . $version;

	my @tuples = [ $perl, $vperl ];
	push @tuples, [ reverse $tuples[0]->@* ];

	foreach my $t ( @tuples ) {
		next unless( -e $t->[0] and !(-e $t->[1]) );
		debug( "Symlinking <$t->[0]> to <$t->[1]>" );
		symlink $t->[0], $t->[1];
		}

	$vperl;
	}

sub make_links ( $perl_path, $version_string, $links_dir = $links_directory ) {
	my @bins = glob( catfile( dirname($perl_path), '*' ) );

	my $count = 0;
	foreach my $bin ( @bins ) {
		debug( "\tlooking at $bin" );
		my $link_basename = do {
			my $basename = basename( $bin );
			if( $basename =~ m/5\.\d+\.\d+\z/) { $basename }
			else                               { "$basename$version_string" }
			};

		my $link = catfile( $links_directory, $link_basename );
		next if( -l $link and $bin eq readlink $link );
		$count++;
		progress_overwrite( sprintf "%s linking %s", '   ', $bin );

		unless( -e $link ) {
			symlink $bin => $link or
				problem( "  Could not create bin symlink [$!]: $bin => $link!" );
			}
		}

	return $count;
	}

sub make_latest ( $latest_perl_path ) {
	foreach my $bin ( glob catfile( dirname($latest_perl_path), '*' ) ) {
		my $basename = basename( $bin );
		$basename =~ s/5\.\d+\.\d+\z//;

		my $link = catfile( $links_directory, "$basename-latest" );
		progress_overwrite( sprintf "%s linking %s for latest", '   ', $bin );
		if( -e $link ) {
			unlink $link or problem( "Could not unlink <$link>: $!" );
			}
		symlink $bin, $link or
			problem( "Could not create latest symlink [$!]: <$bin> => <$link>!" );
		}
	}

sub clear () { print +(' ' x COLUMNS) . "\r" }

sub _message ($message, $ansi = [], $fh = \*STDOUT) {
	$message =~ s/ (?[ [\s] - [\r] ])* \z//x;
	print { $fh } $ansi->@*, $message, reset, $message =~ m/\v/ ? '' : "\n";
	}

sub done     ($message) { clear(); _message( CHECKMARK . '  ' . $message,                    ) }
sub header   ($message) { _message(                    $message, [bold, text_cyan]  ) }
sub problem  ($message) { _message( CROSS . '  ' .     $message, [bold, text_red]   ) }
sub progress ($message) { _message( '  ' .             $message, [bold, text_green] ) }

sub progress_overwrite ($message) {
	state $separator = am_debugging ? "\n" : "\r";
	_message( (' ' x ROWS) . "\r" ) unless am_debugging;
	_message( '  ' .             $message . $separator, [bold, text_green] );
	}

